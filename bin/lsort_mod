#!/usr/bin/env python
import sys
import numpy as np
import glob
from optparse import OptionParser
import l_bp
from sets import Set
import os
from tempfile import gettempdir
from itertools import islice, cycle
from collections import namedtuple
import heapq

Keyed = namedtuple("Keyed", ["key", "obj"])
batchsize=200

def merge(*iterables):
   keyed_iterables = [(Keyed(l_bp.vcf_line_key(obj), obj) for obj in iterable)
                        for iterable in iterables]
   for element in heapq.merge(*keyed_iterables):
       yield element.obj

def main():
    usage ="""%prog -t tempdir [-b batchsize] <VCF file 1> <VCF file 2> ... <VCF file N>


l_sort
Author: Ryan Layer, Colby Chiang, & Ira Hall
Description: sort N VCF files into a single file
Version: 0.01
"""
  

    if len(sys.argv) < 4:
        exit(1)

    import optparse
    parser = optparse.OptionParser()
    parser.add_option(
        '-t','--tempdir',
        dest='tempdir',
        action='store',
        type='string', 
        help='''temporary directory '''
    )
    parser.add_option(
        '-b','--batchsize',
        dest='batchsize',
        action='store',
        default=200,
        type='int',
        help='''number of files to sort in batch '''
    )

    options,args = parser.parse_args()
    vcf_file_names = args
    vcf_lines = []                    # holds current batch of vcflines
    vcf_headers = list()              # all vcf headers
    temp_files = []                   # keep track of temp files
    tempdir=options.tempdir
    if options.batchsize is not None:
       batchsize=options.batchsize

    counter=0
    for vcf_file_name in vcf_file_names:
        samples = l_bp.parse_vcf(vcf_file_name, vcf_lines, vcf_headers)
        for sample in samples:
            vcf_headers.append("##SAMPLE=<ID=" + sample + ">\n")
        counter+=1
        if counter>batchsize:          # sort batch and write to temp file
          vcf_lines.sort(key=l_bp.vcf_line_key)
          temp_outfile = open(os.path.join(tempdir,'%06i'%len(temp_files)),'w+b',64*1024)
          temp_files.append(temp_outfile)
          temp_outfile.writelines(vcf_lines)
          temp_outfile.flush()
          temp_outfile.seek(0)
          #reset counter and vcf_line array
          counter=0
          vcf_lines = []

    # sort last batch and write temp

    vcf_lines.sort(key=l_bp.vcf_line_key)
    temp_outfile = open(os.path.join(tempdir,'%06i'%len(temp_files)),'w+b',64*1024)
    temp_files.append(temp_outfile)
    temp_outfile.writelines(vcf_lines)
    temp_outfile.flush()
    temp_outfile.seek(0)
    
    vcf_headers.append("##INFO=<ID=SNAME,Number=.,Type=String," + \
            "Description=\"Source sample name\">\n")

    vcf_headers.append("##INFO=<ID=ALG,Number=1,Type=String," + \
            "Description=\"Evidence PDF aggregation algorithm\">\n")


    vcf_headers.append("#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\t" + \
            "VARIOUS\n")

    vcf_headers = list(vcf_headers)
    vcf_headers.sort(cmp=l_bp.header_line_cmp)
    sys.stdout.writelines(vcf_headers)
    sys.stdout.writelines(merge(*temp_files))

    for tmp in temp_files:
       tmp.close()
       #os.remove(tmp.name)


if __name__ == "__main__":
    sys.exit(main())
